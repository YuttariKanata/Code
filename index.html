<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Codes (julia)</title>
    <link rel="stylesheet" href="vs2015.css">
    <script src="jl.js"></script>
    <!-- and it's easy to individually load additional languages -->
    <script src="https://fredrikekre.se/assets/julia.highlight.js"></script>


    <style>
        body {
            font-family: Consolas, 'Courier New', monospace;
            max-width: 1000px;
            margin: 2em auto;
            padding: 0 1em;
            line-height: 1.6;
            background-color: #0F1319;
            color: #DADADA;
            font-size: 14px;
            word-break: keep-all;
        }
        h1 {
            text-align: left;
        }
        pre {
            background: #568;
            padding: 2px;
            overflow-x: auto;
            border-radius: 5px;
        }
        .card {
            margin-bottom: 40px;
            padding: 10px;
            
            border-radius: 10px;
            background: #111;
            box-shadow: -10px -10px 10px #111 , 10px 10px 10px #111 , -10px 10px 10px #111 , 10px -10px 10px #111;
        }
        .lang-tag {
            font-size: 0.9em;
            color: #777;
            background-color: #222;
            padding: 0 3px 2px 3px;
            border-radius: 3px;
        }
        a {
            color: #33afc4;
        }
        a:hover{
            color: #33afc4;
            text-decoration-line:none;
        }

        /* コピー用ボタンの基本スタイル */
        .copy-btn {
        position: absolute;
        top: 0.5em;
        right: 0.5em;
        padding: 0.25em 0.5em;
        font-size: 0.8em;
        border: none;
        border-radius: 3px;
        background: #333;
        color: #fff;
        cursor: pointer;
        opacity: 0.6;
        transition: opacity 0.2s;
        }
        .copy-btn:hover {
        opacity: 1;
        }
        /* codeブロックとボタンをまとめるコンテナ */
        .code-container {
        position: relative;
        margin: 1em 0;
        }
    </style>
</head>
<body>
    <h1>Codes</h1>

    <div class="card">
        <h2>完全楕円積分 Elliptic integral</h2>
        <p>参考: <a href="http://totoha.net/fc2_mirror2/Complete_Elliptical_Integral.pdf" target="_blank" rel="noopener noreferrer">第 1 種および第 2 種完全楕円積分の数値計算プログラム   2018.8.3 鈴木 実</a></p>
        <span class="lang-tag">julia</span>
        <div class="code-container"><pre><code class="julia">function th3(q::BigFloat,n::Int64)::BigFloat
    s = zero(BigFloat)
    for i in 1:n
        s += q^(i^2)
    end
    return s*2+1
end

function eps_to_q(eps::BigFloat,n::Int)::BigFloat
    q = zero(BigFloat)
    for i in 1:n
        q = eps_q_for_n(eps,q,i)
    end
    return q
end

function eps_q_for_n(eps::BigFloat,q::BigFloat,n::Int)::BigFloat
    if iseven(n)
        r = eps + 2*q^4*eps
        for i in 4:2:n
            r += (-1)*q^((i-1)^2) + 2*q^(i^2)*eps
        end
    else
        r = eps
        for i in 3:2:n
            r += 2*q^((i-1)^2)*eps - q^(i^2)
        end
    end
    return r
end

#=
q=e + 2q^4e - q^9 + 2q^16e - q^25
0=     - q        - q^9          - q^25
   + e     +2q^4e       + 2q^16e
=#

function sigm(q::BigFloat,ll::Int64)::BigFloat
    s = zero(BigFloat)
    for i in 1:ll
        s += (q^(i&lt;&lt;1))/((1-q^(i&lt;&lt;1))^2)
    end
    return s
end

function yK(k::BigFloat,ll::Int64;is_k_ = false)::BigFloat
    if k^2 &gt;= 0.5 &amp;&amp; !is_k_
        return yK_(k,ll; is_k_ = true)
    end

    if !is_k_
        k_ = sqrt(1-k^2)
    else
        k_ = k
    end

    eps = -(1/2)+1/(1+sqrt(k_))

    q = eps_to_q(eps,ll)

    return (pi/2)*(th3(q,ll))^2
end

function yK_(k::BigFloat,ll::Int64;is_k_ = false)::BigFloat
    if k^2 &gt;= 0.5 &amp;&amp; !is_k_
        return yK(k,ll; is_k_ = true)
    end

    if !is_k_
        k_ = sqrt(1-k^2)
    else
        k_ = k
    end   

    eps = -(1/2)+1/(1+sqrt(k_))

    q = eps_to_q(eps,ll)

    return (-log(q)/2)*(th3(q,ll))^2
end

function yE(k::BigFloat,ll::Int64;is_k_ = false)::BigFloat
    if k^2 &gt;= 0.5 &amp;&amp; !is_k_
        return yE_(sqrt(1-k^2),ll)
    end

    if !is_k_
        k_ = sqrt(1-k^2)
    else
        k_ = k
    end  

    eps = -(1/2)+1/(1+sqrt(k_))

    q = eps_to_q(eps,ll)

    t = th3(q,ll)

    s = sigm(q,1000)


    return pi*( (1/t^2)*(1/BigFloat(6)-4*s) + t^2*((2-k^2)/BigFloat(6)) )
end

function yE_(k::BigFloat,ll::Int64;is_k_ = false)::BigFloat
    if k^2 &gt;= 0.5 &amp;&amp; !is_k_
        return yE(k,ll, is_k_ = true)
    end

    if k &lt;= big&quot;4.5e-154&quot; &amp;&amp; !is_k_
        return 1
    end

    if !is_k_
        k_ = sqrt(1-k^2)
    else
        k_ = k
    end  

    eps = -(1/2)+1/(1+sqrt(k_))

    q = eps_to_q(eps,ll)

    t = th3(q,ll)

    s = sigm(q,1000)

    lnq = log(q)

    return -t^2*lnq*((1+k^2)/BigFloat(6)) + (1/t^2)*(lnq*(1/BigFloat(6)-4*s)+1)
end</code></pre></div>
        実は、SpecialFunctions.jl の実装は piecewise approximation polynomial を使用していると書いています。
        実際中身を見ると確かにそうなってるので、任意精度にするには別の実装がいります。<br>
        あと Elliptic.jl というのもあって、そっちでは引数が ::Float64 にはなっていますが、反復による評価をしているので
        コードだけ引き抜いて ::Float64 を ::BigFloat にして任意精度にするのもいいのかもしれません。<br>
        <br>
        参考文献には ln(1/q) と書いているが -ln(q) とした方が精度がちょっと良くなる。<br>
        ll は反復を何回するか あと途中に sigm(q,1000) とあるが、この 1000 も反復を何回するかなので、
        各自で自分の計算にとって適切な値にしてほしい。<br>
        <br>
        yK の最悪精度を調べてみると、各 ll に対して約 ll*4.556+1.09109 桁の精度(10進数で)が得られました
    </div>

    <div class="card">
        <h2>平方数判定</h2>
        <p>参考: <a href="https://na-inet.jp/na/gmp-6.1.2_ja.pdf" target="_blank" rel="noopener noreferrer">GNU MP p.39</a></p>
        <span class="lang-tag">julia</span>
        <div class="code-container"><pre><code class="julia">
libgmp = Base.GMP.libgmp

perfect_square(x::BigInt) = Int(ccall((:__gmpz_perfect_square_p, libgmp), Cint, (Ref{BigInt},), x))
        </code></pre></div>
        あまり知られていないが、GMPの方に平方数判定専用の関数がある。ccallを使って呼び出せば、
        アセンブラまで最適化された平方数判定関数が手に入る。
        同じようにn乗根を求めて整数部のみ取り出す関数もGMP側にあるので、立方数以上の判定はそれを使うとかするといい。
    </div>

    <div class="card">
        <h2>ε-算法 (数列の加速法)</h2>
        <p><a href="https://www.lab.twcu.ac.jp/~osada//rikei/rikei2008-10.pdf" target="_blank" rel="noopener noreferrer">お話：数値解析 第 6 回   収束の加速法 (中編)    長田直樹</a></p>
        <span class="lang-tag">julia</span>
        <div class="code-container"><pre><code class="julia">
epsilon_array1 = zeros(BigFloat,p)
epsilon_array2 = zeros(BigFloat,p)
for i in 1:p
    epsilon_array2[i] = answer_array[i]
end


for i in 1:Int(floor(p / 2.0)-1)
    epsilon_subarray = 1 ./(circshift(epsilon_array2,-1) .- epsilon_array2)

    epsilon_array1 = circshift(epsilon_array1,-1) .+ epsilon_subarray

    pop!(epsilon_array1)
    pop!(epsilon_array2)

    epsilon_subarray = 1 ./(circshift(epsilon_array1,-1) .- epsilon_array1)

    epsilon_array2 = circshift(epsilon_array2,-1) .+ epsilon_subarray

    pop!(epsilon_array2)
    pop!(epsilon_array1)

end

println()
println("epsilon:")
println(stderr,epsilon_array2[end])

println()
println("epsilon:")
println(stderr,epsilon_array1[end])
        </code></pre></div>
        詳しいことは参考文献を確認してください。
        answer_array が収束させたい数列です。 1 から p まで p 項あるとしています。高速化はしてないです。
    </div>

    <div class="card">
        <h2>2-強擬素数判定関数</h2>
        <p>参考: <a href="https://qiita.com/ayase/items/6b3a2231eec82c2ad43a" target="_blank" rel="noopener noreferrer">ミラーラビン法による確率的素数判定</a></p>
        <span class="lang-tag">julia</span>
        <div class="code-container"><pre><code class="julia">
# 2-強擬素数判定関数
function is_strong_pseudoprime(n::BigInt)
    # n-1 = 2^s * d (d は奇数)
    d = n - 1

    s = trailing_zeros(d)
    d = d>>s

    # x = 2^d mod n
    x = powermod(2, d, n)
    if x == 1 || x == n - 1
        return true
    end
    # 反復平方
    for _ in 2:s
        x = (x * x) % n
        if x == n - 1
            return true
        end
    end
    return false
end
    </code></pre></div>
        trailing_zerosはd*2^sの形にするときによく使うよね
    </div>

    <div class="card">
        <h2>約数関数</h2>
        <p>参考: <a href="https://ja.wikipedia.org/wiki/%E7%B4%84%E6%95%B0%E9%96%A2%E6%95%B0" target="_blank" rel="noopener noreferrer">約数関数 (Wikipedia)</a></p>
        <span class="lang-tag">julia</span>
        <div class="code-container"><pre><code class="julia">
"""
    sigma(n::Integer) -> Integer

与えられた自然数 `n` のすべての正の約数の和 sigma(n) を返す。
"""
function sigma(n::Integer)::BigInt
    n == 1 && return BigInt(1)
    f = factor(n)
    s = BigInt(1)
    for (p, e) in f
        s *= div((BigInt(p)^(e + 1) - 1) , (BigInt(p) - 1))
    end
    return s
end

"""
    sigma(n::Integer, x::Integer) -> Integer

与えられた自然数 `n` のすべての正の約数のx乗和 sigma(n,x) を返す。
"""
function sigma(n::Integer, x::Integer)::BigInt
    n == 1 && return BigInt(1)
    f = factor(n)
    s = BigInt(1)
    if x == 1
        for (p, e) in f
            s *= (e+1)
        end
        return s
    end
    for (p, e) in f
        s *= div((BigInt(p)^((e + 1)*x) - 1) , (BigInt(p)^x - 1))
    end
    return s
end
    </code></pre></div>
        素因数分解して積の形でやると早いよね
    </div>



    <script>
        hljs.highlightAll()
    
        // 2) コピー用ボタンをコードブロックに追加する
        document.querySelectorAll('.code-container').forEach(container => {
            // ボタン要素を作成
            const btn = document.createElement('button');
            btn.innerText = 'Copy';
            btn.className = 'copy-btn';
            container.appendChild(btn);
    
            // クリック時の処理
            btn.addEventListener('click', () => {
                // コードテキストを取得
                const code = container.querySelector('code').innerText;
                // クリップボードに書き込み
                navigator.clipboard.writeText(code).then(() => {
                    // コピー完了フィードバック
                    btn.innerText = 'Copied!';
                    setTimeout(() => btn.innerText = 'Copy', 1000);
                }).catch(err => {
                    console.error('コピーに失敗しました:', err);
                    btn.innerText = 'Error';
                    setTimeout(() => btn.innerText = 'Copy', 1000);
                });
            });
        });
    </script>

</body>
</html>
